{"version":3,"sources":["StreamlitAudioRecorder.tsx","index.tsx"],"names":["StreamlitAudioRecorder","props","canvasRef","sessionId","recordingId","generateRecordingId","Date","now","Math","random","toString","substr","drawWaveform","state","analyser","current","canvas","canvasCtx","getContext","bufferLength","frequencyBinCount","dataArray","Uint8Array","draw","isRecording","animationId","requestAnimationFrame","setState","getByteTimeDomainData","fillStyle","fillRect","width","height","gradient","createLinearGradient","addColorStop","lineWidth","strokeStyle","beginPath","sliceWidth","x","lastY","i","y","moveTo","xc","quadraticCurveTo","lineTo","stroke","cancelAnimationFrame","startRecording","a","navigator","mediaDevices","getUserMedia","audio","channelCount","sampleRate","echoCancellation","noiseSuppression","autoGainControl","stream","audioContext","AudioContext","source","createMediaStreamSource","createAnalyser","connect","mediaRecorder","MediaRecorder","mimeType","audioBitsPerSecond","currentChunks","chunkCounter","ondataavailable","e","data","size","push","prev","previewChunks","sendChunksInterval","setInterval","length","blob","Blob","type","arrayBuffer","buffer","uint8Array","Streamlit","setComponentValue","arr","Object","fromEntries","entries","chunkId","isFinal","onstop","clearInterval","previewBlob","chunks","audioBlob","audioUrl","URL","createObjectURL","start","console","error","stopRecording","stop","getTracks","forEach","track","resetRecording","revokeObjectURL","audioData","downloadRecording","datetime","toLocaleString","replace","filename","document","createElement","style","display","href","download","body","appendChild","click","removeChild","render","theme","borderStyling","border","outline","padding","background","borderRadius","boxShadow","ref","marginBottom","backgroundColor","gap","justifyContent","flexWrap","onClick","color","cursor","src","controls","marginTop","React","createRef","this","StreamlitComponentBase","withStreamlitConnection","setComponentReady","setFrameHeight","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.854d8e71.chunk.js","sourcesContent":["import {\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection,\n} from \"streamlit-component-lib\"\nimport React, { ReactNode } from \"react\"\n\ninterface State {\n  isRecording: boolean\n  mediaRecorder: MediaRecorder | null\n  audioBlob: Blob | null\n  chunks: Blob[]\n  audioUrl: string | null\n  audioData: Float32Array | null\n  analyser: AnalyserNode | null\n  animationId: number | null\n  previewChunks: Blob[]\n}\n\nclass StreamlitAudioRecorder extends StreamlitComponentBase {\n  private canvasRef: React.RefObject<HTMLCanvasElement | null>\n  private sessionId: string;\n  private recordingId: string;\n\n  constructor(props: any) {\n    super(props)\n    this.state = {\n      isRecording: false,\n      mediaRecorder: null,\n      audioBlob: null,\n      chunks: [],\n      audioUrl: null,\n      audioData: null,\n      analyser: null,\n      animationId: null,\n      previewChunks: []\n    }\n    this.canvasRef = React.createRef<HTMLCanvasElement | null>()\n    this.sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n    this.recordingId = this.generateRecordingId();\n  }\n\n  generateRecordingId = (): string => {\n    return 'rec_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n  }\n\n  componentDidMount() {\n    // Initialize canvas with a modern look\n    if (this.canvasRef.current) {\n      const canvas = this.canvasRef.current\n      const canvasCtx = canvas.getContext('2d')\n      if (canvasCtx) {\n        canvasCtx.fillStyle = '#f0f0f0'\n        canvasCtx.fillRect(0, 0, canvas.width, canvas.height)\n        \n        // Create gradient for the line\n        const gradient = canvasCtx.createLinearGradient(0, 0, canvas.width, 0)\n        gradient.addColorStop(0, '#ff4b4b')\n        gradient.addColorStop(1, '#ff8b8b')\n        \n        canvasCtx.strokeStyle = gradient\n        canvasCtx.lineWidth = 3\n        canvasCtx.beginPath()\n        canvasCtx.moveTo(0, canvas.height / 2)\n        canvasCtx.lineTo(canvas.width, canvas.height / 2)\n        canvasCtx.stroke()\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.state.animationId) {\n      cancelAnimationFrame(this.state.animationId)\n    }\n  }\n\n  drawWaveform = () => {\n    if (this.state.analyser && this.canvasRef.current) {\n      const canvas = this.canvasRef.current\n      const canvasCtx = canvas.getContext('2d')\n      const bufferLength = this.state.analyser.frequencyBinCount\n      const dataArray = new Uint8Array(bufferLength)\n\n      const draw = () => {\n        if (!this.state.isRecording) {\n          if (this.state.animationId) {\n            cancelAnimationFrame(this.state.animationId)\n          }\n          return\n        }\n\n        const animationId = requestAnimationFrame(draw)\n        this.setState({ animationId })\n\n        this.state.analyser!.getByteTimeDomainData(dataArray)\n\n        if (canvasCtx) {\n          // Modern background\n          canvasCtx.fillStyle = '#f0f0f0'\n          canvasCtx.fillRect(0, 0, canvas.width, canvas.height)\n\n          // Create gradient for the waveform\n          const gradient = canvasCtx.createLinearGradient(0, 0, canvas.width, 0)\n          gradient.addColorStop(0, '#ff4b4b')\n          gradient.addColorStop(1, '#ff8b8b')\n          \n          canvasCtx.lineWidth = 3\n          canvasCtx.strokeStyle = gradient\n          canvasCtx.beginPath()\n\n          const sliceWidth = (canvas.width * 1.0) / bufferLength\n          let x = 0\n          let lastY = canvas.height / 2\n\n          for (let i = 0; i < bufferLength; i++) {\n            const v = dataArray[i] / 128.0\n            const y = (v * canvas.height) / 2\n\n            // Smooth the line using bezier curves\n            if (i === 0) {\n              canvasCtx.moveTo(x, y)\n            } else {\n              const xc = (x + (x - sliceWidth)) / 2\n              canvasCtx.quadraticCurveTo(x - sliceWidth, lastY, xc, y)\n            }\n\n            lastY = y\n            x += sliceWidth\n          }\n\n          canvasCtx.lineTo(canvas.width, canvas.height / 2)\n          canvasCtx.stroke()\n        }\n      }\n\n      draw()\n    }\n  }\n\n  startRecording = async () => {\n    try {\n      this.recordingId = this.generateRecordingId();\n\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          channelCount: 1,\n          sampleRate: 44100,\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true\n        }\n      })\n\n      const audioContext = new AudioContext()\n      const source = audioContext.createMediaStreamSource(stream)\n      const analyser = audioContext.createAnalyser()\n      source.connect(analyser)\n      \n      const mediaRecorder = new MediaRecorder(stream, {\n        mimeType: 'audio/webm;codecs=opus',\n        audioBitsPerSecond: 128000\n      })\n\n      // Send chunks every 5 seconds to stay well under Streamlit's size limits\n      const CHUNK_INTERVAL = 5000; // 5 seconds\n      let currentChunks: Blob[] = [];\n      let chunkCounter = 0;\n\n      mediaRecorder.ondataavailable = (e: BlobEvent) => {\n        if (e.data.size > 0) {\n          currentChunks.push(e.data);\n          this.setState((prev: State) => ({\n            previewChunks: [...prev.previewChunks, e.data]\n          }));\n        }\n      };\n\n      // Periodically send chunks\n      const sendChunksInterval = setInterval(async () => {\n        if (currentChunks.length > 0 && this.state.isRecording) {\n          const blob = new Blob(currentChunks, { type: 'audio/webm;codecs=opus' });\n          currentChunks = []; // Clear current chunks after creating blob\n          \n          const buffer = await blob.arrayBuffer();\n          const uint8Array = new Uint8Array(buffer);\n          Streamlit.setComponentValue({\n            arr: Object.fromEntries(uint8Array.entries()),\n            chunkId: chunkCounter++,\n            sessionId: this.sessionId,\n            recordingId: this.recordingId,\n            isFinal: false\n          });\n        }\n      }, CHUNK_INTERVAL);\n\n      mediaRecorder.onstop = async () => {\n        clearInterval(sendChunksInterval);\n        \n        // Send any remaining chunks\n        if (currentChunks.length > 0) {\n          const blob = new Blob(currentChunks, { type: 'audio/webm;codecs=opus' });\n          const buffer = await blob.arrayBuffer();\n          const uint8Array = new Uint8Array(buffer);\n          Streamlit.setComponentValue({\n            arr: Object.fromEntries(uint8Array.entries()),\n            chunkId: chunkCounter,\n            sessionId: this.sessionId,\n            recordingId: this.recordingId,\n            isFinal: true\n          });\n        }\n\n        // Create preview blob from all chunks\n        const previewBlob = new Blob(this.state.previewChunks, { type: 'audio/webm;codecs=opus' });\n        \n        this.setState({ \n          chunks: [], \n          previewChunks: [],\n          isRecording: false,\n          mediaRecorder: null,\n          audioBlob: previewBlob,\n          audioUrl: URL.createObjectURL(previewBlob)\n        });\n      };\n\n      // Start recording in smaller intervals for smooth waveform\n      mediaRecorder.start(100);\n      this.setState({ \n        mediaRecorder, \n        isRecording: true, \n        analyser,\n        previewChunks: [],  // Clear preview chunks when starting new recording\n        audioUrl: null,     // Clear previous audio URL\n        audioBlob: null     // Clear previous blob\n      }, this.drawWaveform);\n\n    } catch (err) {\n      console.error(\"Error accessing microphone:\", err)\n    }\n  }\n\n  stopRecording = () => {\n    if (this.state.mediaRecorder && this.state.isRecording) {\n      this.state.mediaRecorder.stop()\n      this.state.mediaRecorder.stream.getTracks().forEach((track: MediaStreamTrack) => track.stop())\n      if (this.state.animationId) {\n        cancelAnimationFrame(this.state.animationId)\n      }\n    }\n  }\n\n  resetRecording = (): void => {\n    if (this.state.animationId) {\n      cancelAnimationFrame(this.state.animationId)\n    }\n\n    if (this.state.audioUrl) {\n      URL.revokeObjectURL(this.state.audioUrl);\n    }\n\n    this.recordingId = this.generateRecordingId();\n\n    this.setState({\n      isRecording: false,\n      audioBlob: null,\n      chunks: [],\n      previewChunks: [],\n      audioUrl: null,\n      audioData: null,\n      analyser: null,\n      animationId: null\n    })\n    \n    Streamlit.setComponentValue({\n      type: 'reset',\n      sessionId: this.sessionId,\n      recordingId: this.recordingId\n    })\n  }\n\n  downloadRecording = (): void => {\n    if (this.state.audioBlob) {\n      const datetime = new Date().toLocaleString()\n        .replace(/[\\s,]/g, '')\n        .replace(/_/g, '')\n      const filename = `streamlit_audio_${datetime}.webm`\n\n      const a = document.createElement('a')\n      a.style.display = 'none'\n      a.href = URL.createObjectURL(this.state.audioBlob)\n      a.download = filename\n      document.body.appendChild(a)\n      a.click()\n      document.body.removeChild(a)\n    }\n  }\n\n  public render = (): ReactNode => {\n    const theme = this.props.theme\n    const style: React.CSSProperties = {}\n\n    if (theme) {\n      const borderStyling = `1px solid ${\n        this.state.isRecording ? '#ff4b4b' : \"#e0e0e0\"\n      }`\n      style.border = borderStyling\n      style.outline = borderStyling\n    }\n\n    return (\n      <div style={{ padding: '20px', background: 'white', borderRadius: '10px', boxShadow: '0 2px 10px rgba(0,0,0,0.1)' }}>\n        <canvas \n          ref={this.canvasRef} \n          width=\"500\" \n          height=\"100\" \n          style={{ \n            width: '100%', \n            marginBottom: '20px', \n            borderRadius: '5px',\n            backgroundColor: this.state.isRecording ? '#fff4f4' : '#f0f0f0'\n          }}\n        />\n        \n        <div style={{ display: 'flex', gap: '10px', justifyContent: 'center', flexWrap: 'wrap' }}>\n          {!this.state.isRecording ? (\n            <button\n              onClick={this.startRecording}\n              style={{\n                padding: '10px 20px',\n                borderRadius: '5px',\n                border: 'none',\n                backgroundColor: '#ff4b4b',\n                color: 'white',\n                cursor: 'pointer'\n              }}\n            >\n              Start Recording\n            </button>\n          ) : (\n            <button\n              onClick={this.stopRecording}\n              style={{\n                padding: '10px 20px',\n                borderRadius: '5px',\n                border: 'none',\n                backgroundColor: '#4b4bff',\n                color: 'white',\n                cursor: 'pointer'\n              }}\n            >\n              Stop Recording\n            </button>\n          )}\n          \n          {this.state.audioUrl && (\n            <>\n              <button\n                onClick={this.resetRecording}\n                style={{\n                  padding: '10px 20px',\n                  borderRadius: '5px',\n                  border: 'none',\n                  backgroundColor: '#ff8c4b',\n                  color: 'white',\n                  cursor: 'pointer'\n                }}\n              >\n                Reset Recording\n              </button>\n              <audio \n                src={this.state.audioUrl} \n                controls \n                style={{ marginTop: '10px', width: '100%' }}\n              />\n            </>\n          )}\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default withStreamlitConnection(StreamlitAudioRecorder)\n\nStreamlit.setComponentReady()\nStreamlit.setFrameHeight()\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport StAudioRec from \"./StreamlitAudioRecorder\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <StAudioRec />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}